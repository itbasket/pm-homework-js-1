console.log(2 + '2' == '2' + 2) // true
/*  выполняется левый плюс, потом правый. 
    В обоих случаях результатом будет строка '22' (так как один операнд строка, второй тоже преобразуется к строке бинарным оператором плюса). 
    Они идентичны, поэтому при сравнении получим true
*/

console.log(2 + '3' == '3' + 2) // false
/*  выполняется левый плюс, потом правый. 
    Результатами будут строки '23' и '32' (так как один операнд строка, второй тоже преобразуется к строке бинарным оператором плюса). 
    Строки отличаются, поэтому при сравнении получим false
*/

console.log('3' + '2' == 3 + 2) // false
/*  выполняется левый плюс, потом правый. 
    Результатами будут строка '32' и число 5.
    Так как сравнение нестрогое, строка 32 будет автоматически приведена к числу 32, которое не равно 5. Соответственно результат false
*/

console.log('3' + '2' == '3' + 2) // true
/*  выполняется левый плюс, потом правый. 
    В обоих случаях результатом будет строка '32' (так как один операнд строка, второй тоже преобразуется к строке бинарным оператором плюса). 
    Они идентичны, поэтому при сравнении получим true
*/

console.log('3' + '2' == 2 + '3') // false
/*  выполняется левый плюс, потом правый. 
    Результатами будут строки '32' и '23' (так как один операнд строка, второй тоже преобразуется к строке бинарным оператором плюса). 
    Строки отличаются, поэтому при сравнении получим false
*/

console.log(2 + Number('3') == Number('3') + 2) // true
/*  Сначала обе строки '3' будут явно приведены к числу 3
    дальше выполняется левый плюс, потом правый. 
    В обоих случаях плюсуются уже только числа и результатом будет число 5. 
    Они идентичны, поэтому при сравнении получим true
*/



console.log(12 / '6') // 2
/*  Оператор деления автоматически приводит операнды к числу. 
    Результатом операции 12 / 6 является 2. 
*/

console.log('number' + 15 + 3) // 'number153'
/*  Сначала выполняется левый плюс. Число 15 приводится к строке и добавляется к строке 'number'. Получаем строку 'number15'.
    Дальше выполняется второй плюс, где к полученной строке добавляется строка '3' автоматически получившаяся из числа 3.
    Конечный результат - строка 'number153'
*/

console.log(15 + 3 + 'number') // '18number'
/*  Сначала выполняется левый плюс. Складываются два числа, получается число 18.
    Дальше выполняется второй плюс, где полученное число 18 приводится к строке '18' и плюсуется к строке 'number'.
    Конечный результат - строка '18number'
*/

console.log([1] > null) // true
/*  Здесь оба операнда приводятся к числу - массив [1] к 1, а null к 0.
    1 больше 0, поэтому результат true
    Кстати, к числу может быть преобразован только массив с одним элементом. Если бы их было больше, он бы преобразовался к NaN и результатом был бы false
*/

console.log('foo' + + 'bar') // 'fooNaN'
/*  Первый плюс считается бинарным, а второй унарным. Сначал выполняется второй. Он пытается преобразовать строку 'bar' к числу, но это невозможно, поэтому получается NaN.
    Дальше выполняется первый плюс, он складывает строку 'foo' и NaN (преобразуется к строке 'NaN').
    Конечный результат - строка 'fooNaN'
*/

console.log('true' == true) // false
/*  Оператор сравнения в данном случае приводит оба операнда к числу.
    Строка 'true' не может быть приведена к числу, поэтому получается NaN, а вот булевое значение true приводится к числу 1
    NaN не равен 1, результат - false
*/

console.log(false == 'false') // false
/*  Тут всё аналогично предыдущему примеру, после приведения к числам получаем сравнение 0 == NaN.
    Результат - false
*/

console.log(null == '') // false
/*  null может быть равен только себе или undefined при нестрогом сравнении
    В остальных случаях любое сравнение с null даёт false
*/

console.log(!!'false' == !!'true') // true
/*  Унарный оператор ! приводит операнд к булевому типу, но также инвертирует его. Поэтому двойное инвертирование !! просто приводит операнд к булевому типу.
    Обе строки не пусты, а значит будут преобразованы в true.
    Соответственно результат тоже true
*/

console.log([`x`] == `x`) // true
/*  Массив преобразуется к строке 'x'
    Обе строки равны, результат true
*/



const enemy = {
    name: 'Bob'
};
const friend = {
    name: 'Alex'
};
const me = friend;

me.name = 'Bob';

console.log(friend.name); // 'Bob'
console.log(me === friend); // true
console.log(me === enemy); // false
/*  
    Мы положили в константу me ссылку на объект friend, поэтому me и friend ссылаются на один и тот же объект. 
    Изменив имя через me, результат изменений видно также через friend.
    me === friend так как ведут на один объект в памяти.
    me !== enemy так как ведут на разные объекты, хоть и с одинаковыми свойствами.
*/


const month = prompt('Введите месяц')
let result = ''
if (+month.isNaN()) {
    switch (month) {
        case 'January':
            result = 1
            break;
        case 'February':
            result = 2
            break;
        case 'March':
            result = 3
            break;
        case 'April':
            result = 4
            break;
        case 'May':
            result = 5
            break;
        case 'June':
            result = 6
            break;
        case 'July':
            result = 7
            break;
        case 'August':
            result = 8
            break;
        case 'September':
            result = 9
            break;
        case 'October':
            result = 10
            break;
        case 'November':
            result = 11
            break;
        case 'December':
            result = 12
            break;
        default:
            result = 'wrong month'
    }
} else {
    switch (month) {
        case 1:
            result = 'January'
            break;
        case 2:
            result = 'February'
            break;
        case 3:
            result = 'March'
            break;
        case 4:
            result = 'April'
            break;
        case 5:
            result = 'May'
            break;
        case 6:
            result = 'June'
            break;
        case 7:
            result = 'July'
            break;
        case 8:
            result = 'August'
            break;
        case 9:
            result = 'September'
            break;
        case 10:
            result = 'October'
            break;
        case 11:
            result = 'November'
            break;
        case 12:
            result = 'December'
            break;
        default:
            result = 'wrong month'
    }
}
alert(result)